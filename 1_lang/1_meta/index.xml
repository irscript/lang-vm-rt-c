<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>语言描述语法 on air 编程语言</title>
    <link>https://irscript.github.io/lang-vm-rt-c/1_lang/1_meta/index.html</link>
    <description>Recent content in 语言描述语法 on air 编程语言</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://irscript.github.io/lang-vm-rt-c/1_lang/1_meta/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>巴科斯范式：BNF</title>
      <link>https://irscript.github.io/lang-vm-rt-c/1_lang/1_meta/1_bnf/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://irscript.github.io/lang-vm-rt-c/1_lang/1_meta/1_bnf/index.html</guid>
      <description>巴科斯范式：BNF 巴科斯范式 以美国人巴科斯(Backus)和丹麦人诺尔(Naur)的名字命名的一种形式化的语法表示方法，用来描述语法的一种形式体系，是一种典型的元语言。又称巴科斯-诺尔形式(Backus-Naur form)。它不仅能严格地表示语法规则，而且所描述的语法是与上下文无关的。
它具有语法简单，表示明确，便于语法分析和编译的特点。
BNF表示语法规则的方式为：
非终结符用尖括号括起。 每条规则的左部是一个非终结符，右部是由非终结符和终结符组成的一个符号串，中间一般以“::=”分开。 具有相同左部的规则可以共用一个左部，各右部之间以直竖“|”隔开。 BNF 详细规则 在双引号中的字(&amp;ldquo;word&amp;rdquo;)代表着这些字符本身。而double_quote用来代表双引号。 在双引号外的字（有可能有下划线）代表着语法部分。 尖括号( &amp;lt; &amp;gt; )内包含的为必选项。 方括号( [ ] )内包含的为可选项。 大括号( { } )内包含的为可重复0至无数次的项。 竖线( | )表示在其左右两边任选一项，相当于&amp;quot;OR&amp;quot;的意思。 ::= 是“被定义为”的意思。 C 语言的 BNF 定义 1%token int_const char_const float_const id string enumeration_const 2%% 3 4translation_unit	: external_decl 5	| translation_unit external_decl 6	; 7external_decl	: function_definition 8	| decl 9	; 10function_definition	: decl_specs declarator decl_list compound_stat 11	|	declarator decl_list compound_stat 12	| decl_specs declarator	compound_stat 13	|	declarator compound_stat 14	; 15decl	: decl_specs init_declarator_list &amp;#39;;&amp;#39; 16	| decl_specs	&amp;#39;;&amp;#39; 17	; 18decl_list	: decl 19	| decl_list decl 20	; 21decl_specs	: storage_class_spec decl_specs 22	| storage_class_spec 23	| type_spec decl_specs 24	| type_spec 25	| type_qualifier decl_specs 26	| type_qualifier 27	; 28storage_class_spec	: &amp;#39;auto&amp;#39; | &amp;#39;register&amp;#39; | &amp;#39;static&amp;#39; | &amp;#39;extern&amp;#39; | &amp;#39;typedef&amp;#39; 29	; 30type_spec	: &amp;#39;void&amp;#39; | &amp;#39;char&amp;#39; | &amp;#39;short&amp;#39; | &amp;#39;int&amp;#39; | &amp;#39;long&amp;#39; | &amp;#39;float&amp;#39; 31	| &amp;#39;double&amp;#39; | &amp;#39;signed&amp;#39; | &amp;#39;unsigned&amp;#39; 32	| struct_or_union_spec 33	| enum_spec 34	| typedef_name 35	; 36type_qualifier	: &amp;#39;const&amp;#39; | &amp;#39;volatile&amp;#39; 37	; 38struct_or_union_spec	: struct_or_union id &amp;#39;{&amp;#39; struct_decl_list &amp;#39;}&amp;#39; 39	| struct_or_union	&amp;#39;{&amp;#39; struct_decl_list &amp;#39;}&amp;#39; 40	| struct_or_union id 41	; 42struct_or_union	: &amp;#39;struct&amp;#39; | &amp;#39;union&amp;#39; 43	; 44struct_decl_list	: struct_decl 45	| struct_decl_list struct_decl 46	; 47init_declarator_list	: init_declarator 48	| init_declarator_list &amp;#39;,&amp;#39; init_declarator 49	; 50init_declarator	: declarator 51	| declarator &amp;#39;=&amp;#39; initializer 52	; 53struct_decl	: spec_qualifier_list struct_declarator_list &amp;#39;;&amp;#39; 54	; 55spec_qualifier_list	: type_spec spec_qualifier_list 56	| type_spec 57	| type_qualifier spec_qualifier_list 58	| type_qualifier 59	; 60struct_declarator_list	: struct_declarator 61	| struct_declarator_list &amp;#39;,&amp;#39; struct_declarator 62	; 63struct_declarator	: declarator 64	| declarator &amp;#39;:&amp;#39; const_exp 65	|	&amp;#39;:&amp;#39; const_exp 66	; 67enum_spec	: &amp;#39;enum&amp;#39; id &amp;#39;{&amp;#39; enumerator_list &amp;#39;}&amp;#39; 68	| &amp;#39;enum&amp;#39;	&amp;#39;{&amp;#39; enumerator_list &amp;#39;}&amp;#39; 69	| &amp;#39;enum&amp;#39; id 70	; 71enumerator_list	: enumerator 72	| enumerator_list &amp;#39;,&amp;#39; enumerator 73	; 74enumerator	: id 75	| id &amp;#39;=&amp;#39; const_exp 76	; 77declarator	: pointer direct_declarator 78	|	direct_declarator 79	; 80direct_declarator	: id 81	| &amp;#39;(&amp;#39; declarator &amp;#39;)&amp;#39; 82	| direct_declarator &amp;#39;[&amp;#39; const_exp &amp;#39;]&amp;#39; 83	| direct_declarator &amp;#39;[&amp;#39;	&amp;#39;]&amp;#39; 84	| direct_declarator &amp;#39;(&amp;#39; param_type_list &amp;#39;)&amp;#39; 85	| direct_declarator &amp;#39;(&amp;#39; id_list &amp;#39;)&amp;#39; 86	| direct_declarator &amp;#39;(&amp;#39;	&amp;#39;)&amp;#39; 87	; 88pointer	: &amp;#39;*&amp;#39; type_qualifier_list 89	| &amp;#39;*&amp;#39; 90	| &amp;#39;*&amp;#39; type_qualifier_list pointer 91	| &amp;#39;*&amp;#39;	pointer 92	; 93type_qualifier_list	: type_qualifier 94	| type_qualifier_list type_qualifier 95	; 96param_type_list	: param_list 97	| param_list &amp;#39;,&amp;#39; &amp;#39;.</description>
    </item>
    <item>
      <title>扩展巴科斯范式：EBNF</title>
      <link>https://irscript.github.io/lang-vm-rt-c/1_lang/1_meta/2_ebnf/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://irscript.github.io/lang-vm-rt-c/1_lang/1_meta/2_ebnf/index.html</guid>
      <description>扩展巴科斯范式：EBNF 扩展巴科斯-瑙尔范式(EBNF, Extended Backus–Naur Form) 是表达作为描述计算机编程语言形式语言(是用精确的数学或机器可处理的公式定义的语言) 的正规方式的上下文无关文法 的元语法(metalanguage)符号表示法。
它是 巴科斯范式(BNF) 元语法符号表示法的一种扩展。
简单的理解就是用来描述 语言词法 和 语法规则 的语言。
EBNF 基本形式 LEFT=RIGHT 意思为LEFT可由RIGHT推导而来，LEFT为非终结符，RIGHT可以为非终结符也可以为终结符； 非终结符 简单的理解就是可以继续推导的符号 终结符 不可被推导的符号。
EBNF 符号 符号 含义 示例 = 定义 CharA=&amp;ldquo;a&amp;rdquo; ; 代表CharA由字母a推导而来 , 连接符 a,b,c 代表abc是挨着的 ; 结束符 CharA=&amp;ldquo;a&amp;rdquo;; 代表 CharA这条语句定义结束 | 或者 digit = &amp;ldquo;0&amp;rdquo; | &amp;ldquo;1&amp;rdquo; | &amp;ldquo;2&amp;rdquo; | &amp;ldquo;3&amp;rdquo; | &amp;ldquo;4&amp;rdquo; | &amp;ldquo;5&amp;rdquo; | &amp;ldquo;6&amp;rdquo; | &amp;ldquo;7&amp;rdquo; | &amp;ldquo;8&amp;rdquo; | &amp;ldquo;9&amp;rdquo;; [&amp;hellip;] 可选，出现0次或1次 number = [&amp;quot;-&amp;quot; | &amp;ldquo;+&amp;rdquo;],digit 可匹配 1 -1 +1 &amp;hellip; {&amp;hellip;} 重复，出现&amp;gt;=0次 number = [&amp;quot;-&amp;quot; | &amp;ldquo;+&amp;rdquo;],digit,{digit} 可匹配 1 -1 +1 11 &amp;hellip; (&amp;hellip;) 分组 number = （&amp;quot;-&amp;quot; | &amp;ldquo;+&amp;quot;）,digit 符号必须添加，可匹配 -1 +1 &amp;hellip; &amp;ldquo;&amp;hellip;&amp;ldquo;或者&amp;rsquo;&amp;hellip;&#39; 终结符,单引号主要是一些特殊情况，比如双引号 &amp;ldquo;a&amp;quot;或者&amp;rsquo;a&amp;rsquo; 由单或双引号引起来的部分是终结符，就是代表字母a，不可继续推导 (* &amp;hellip; *) 注释 (我是注释) 注释不参与定义 ?</description>
    </item>
    <item>
      <title>增强巴科斯范式：ABNF</title>
      <link>https://irscript.github.io/lang-vm-rt-c/1_lang/1_meta/3_abnf/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://irscript.github.io/lang-vm-rt-c/1_lang/1_meta/3_abnf/index.html</guid>
      <description>增强巴科斯范式：ABNF RFC2234 定义了扩展的巴科斯范式(ABNF)。近年来在Internet的定义中 ABNF 被广泛使用。ABNF 做了更多的改进。扩充巴科斯-瑙尔范式(ABNF)基于了巴科斯-瑙尔范式(BNF)，但由它自己的语法和推导规则构成。这种元语言的发起原则是描述作为通信协议(双向规范)的语言的形式系统。它建档于 RFC 4234 中通常充当 IETF 通信协议的定义语言。
ABNF 规则 一个ABNF规范是一些推导规则的集合，书写为：规则 = 定义;注释CR LF 其中：
“规则”是不区分大小写的非最终符号 “定义”由定义该规则的一系列符号组成 “注释”用于记录 “CR LF”（回车、换行）用来结束 规则名字是不区分大小写的:,,和都提及同一个规则。
规则名字由一个字母以及后续的多个字母、数字和连字符（减号）组成。
用尖括号（“&amp;lt;”，“&amp;gt;”）包围规则名并不是必需的（如同它们在BNF里那样），但是它们可以用来在描述中界定规则名，以方便识别出规则名。
ABNF 使用标准 ASCII 编码。
终结符由一个或多个数值字符指定。数值字符可以指定为跟随着基数(b = 二进制, d = 十进制, x = 十六进制)的一个百分号“%”，随后是这个数值，或数值的串联(用“.” 来指示)。例如回车可以指定为十进制的 %d13 或十六进制的 %x0D。回车换行可以指定为 %d13.10。
文字正文通过使用包围在引号(&amp;quot;)中字符串来指定。这些字符串是大小写不敏感的，使用的字符集是 US-ASCII。所以字符串“abc”将匹配“abc”, “Abc”, “aBc”, “abC”, “ABc”, “AbC”, “aBC” 和 “ABC”。对于大小写敏感匹配，必须定义明确的字符: 要匹配 “aBc” 定义将是 %d97 %d66 %d99。
ABNF 操作符 空白被用来分隔定义的各个元素: 要使空格被识别为分割符则必须明确的包含它。
串联 规则1 规则2 规则可以通过列出一序列的规则名字来定义。
例如要匹配字符串“aba”可以使用下列规则:
fu = %x61; a bar = %x62; b mumble = fu bar fu 选择 规则1 / 规则2 规则可以通过用反斜杠(“/”)分隔的多选一规则来定义。</description>
    </item>
  </channel>
</rss>