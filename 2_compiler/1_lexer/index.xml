<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>词法分析 on air 编程语言</title>
    <link>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/index.html</link>
    <description>Recent content in 词法分析 on air 编程语言</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>字符抽象</title>
      <link>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/1_char/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/1_char/index.html</guid>
      <description>字符抽象是编译器在处理源代码时的一种重要机制。在编程中，我们使用的字符实际上可以被看作是特定的整数值（通常是ASCII值或者Unicode值）。编译器在读取源代码时，会将这些字符转换成对应的整数值，并进行相应的操作。
例如，在C语言中，我们可以使用字符字面量来表示单个字符，如&amp;rsquo;a&amp;rsquo;或&#39;5&amp;rsquo;。编译器会将这些字符字面量解析为它们对应的整数值，并在需要的时候将其转换回字符形式。
此外，编译器还会对字符串进行特殊的处理。在C语言中，字符串实际上是字符数组，每个元素都包含了字符的整数值。当编译器遇到一个字符串字面量，如&amp;quot;Hello, world!&amp;quot;，它会创建一个包含所有字符的数组，并在末尾添加一个空字符（其整数值通常为0），以表示字符串的结束。
总的来说，字符抽象使得编译器能够有效地处理文本数据，并且不需要程序员关注底层的细节。通过这种方式，程序员可以更加专注于编写逻辑清晰、易于维护的代码。
好处 在词法分析中，对字符抽象的好处主要体现在以下几个方面：
简化处理逻辑：通过将输入的字符序列转换为一个更高级别的表示（如单词或符号），编译器可以忽略掉字符编码的细节，简化处理过程。例如，无论源代码使用的是ASCII还是Unicode编码，编译器都可以将其统一视为一个整数值流。 提高识别效率：通过对字符进行分类和归类，可以更快地识别出有意义的单词和符号。比如，在识别关键字时，只需要检查某个字符串是否与预定义的关键字列表匹配即可，而不需要关心每个字符的具体值。 便于错误检测：词法分析阶段通常会首先执行错误检测，如检查拼写错误、未闭合的括号等。使用字符抽象可以帮助编译器更容易地定位这些问题，并提供有用的错误信息。 减少后续阶段的工作量：对字符进行抽象后生成的词法单元是语法分析阶段的主要输入。如果在词法分析阶段就能够正确地区分不同类型的词素（如标识符、数字、运算符等），那么语法分析阶段就可以直接使用这些词素，而不需要重新处理原始的字符数据。 支持跨平台编译：对于不同的操作系统和硬件平台，可能使用的字符编码不同。通过在词法分析阶段进行字符抽象，编译器可以在一定程度上独立于具体的字符编码，从而提高代码的可移植性。 通过字符抽象，词法分析器能够以一种更加高效且平台无关的方式处理源代码，使得整个编译过程更加可靠和健壮。 实现 1// 字符封装 2struct Char 3{ 4 uint32_t pos; // 在字符流的位置 5 uint32_t val; // 字符值 6 7 inline Char(uint32_t pos, uint32_t ch) 8 : pos(pos), val(ch) {} 9 10 inline bool isalpha() const { return ::isalpha(val); } // 字母？ 11 inline bool isdigit() const { return ::isdigit(val); } // 数字 12 inline bool isalnum() const { return ::isalnum(val); } // 数字和字母？ 13 14 inline bool isalpha_() const { return val == &amp;#39;_&amp;#39; || ::isalpha(val); } // 字母、下划线_？ 15 inline bool isalnum_() const { return val == &amp;#39;_&amp;#39; || ::isalnum(val); } // 字母、下划线_、数字？ 16 17 // 空白字符？ 18 inline bool isWhiteSpace() const 19 { 20 switch (val) 21 { 22 case &amp;#39; &amp;#39;: 23 case &amp;#39;\t&amp;#39;: 24 case &amp;#39;\v&amp;#39;: 25 case &amp;#39;\r&amp;#39;: 26 case &amp;#39;\n&amp;#39;: 27 return true; 28 } 29 return false; 30 } 31 32 // 空字符？ 33 inline bool isNull() const { return val == &amp;#39;\0&amp;#39;; } 34 // 16进制字符 35 inline bool isHex() const 36 { 37 if (&amp;#39;a&amp;#39; &amp;lt;= val &amp;amp;&amp;amp; val &amp;lt;= &amp;#39;f&amp;#39;) 38 return true; 39 if (&amp;#39;A&amp;#39; &amp;lt;= val &amp;amp;&amp;amp; val &amp;lt;= &amp;#39;F&amp;#39;) 40 return true; 41 return isdigit(); 42 } 43 // 8进制字符 44 inline bool isOct() const 45 { 46 return &amp;#39;0&amp;#39; &amp;lt;= val &amp;amp;&amp;amp; val &amp;lt;= &amp;#39;7&amp;#39;; 47 } 48 // 2进制字符 49 inline bool isBin() const { return &amp;#39;0&amp;#39; == val || &amp;#39;1&amp;#39; == val; } 50 51 // 字符判断 52 inline bool isChar(uint32_t ch) const { return val == ch; } 53};</description>
    </item>
    <item>
      <title>字符流抽象</title>
      <link>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/2_stream/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/2_stream/index.html</guid>
      <description>字符流抽象是指在编程和软件开发中，将底层的字节流或字符编码处理细节隐藏起来，提供一个更高级别的接口来操作文本数据。这样做的目的是简化程序设计，提高代码可读性，并使开发者可以专注于应用程序的逻辑和语义，而不是底层的实现细节。
在编译器中，词法分析阶段通常会对输入的源代码进行字符流抽象。这一阶段会将原始的字符序列转换为一系列有意义的单元，如标识符、关键字、数字、运算符等，这些单元被称为词法单元（或称为标记、符号）。每个词法单元都有对应的类型和值，这使得后续的语法分析和语义分析阶段能够更容易地理解和处理源代码。
此外，字符流抽象也经常出现在IO库的设计中，例如Java中的Reader和Writer类，或者C++中的iostream库。这些库提供了一个统一的方式来读取和写入字符流，无论底层的字符编码如何变化。使用这些库的开发者通常不需要关心字符编码的具体细节，从而可以更加高效地编写跨平台和兼容多种字符集的代码。
总的来说，字符流抽象是一种强大的工具，它可以帮助程序员更好地处理文本数据，而无需深入了解底层的字符编码细节。
好处 在词法分析中对字符流进行抽象有以下几个主要好处：
提高处理效率：对输入的字符流进行抽象，可以有效地将连续的字符组合成有意义的单元（如标识符、关键字、数字和运算符）。这有助于减少语法分析阶段需要处理的元素数量，从而提高编译器的整体效率。 更少的错误：通过将字符流转换为更高级别的表示，编译器能够更容易地检测出潜在的错误。例如，一个未闭合的字符串常量或注释可能会导致后续的解析错误；通过在词法分析阶段识别这些错误，可以提前报告并提供更准确的错误信息。 通用性与可移植性：字符流抽象使得编译器可以不关心具体的字符编码细节，比如ASCII、ISO-8859-1或者Unicode等。这种特性使得编译器能够在多种平台上运行，而无需针对每个平台进行特定的修改。 简化程序结构：词法分析器的设计和实现通常会利用字符流抽象的概念，比如使用有限自动机（FA）或正则表达式来匹配模式。这种方法简化了代码，使其更具可读性和维护性。 隐藏复杂性：对于程序员而言，他们通常关注于源代码的逻辑和语义，而非底层的字符编码。通过对字符流的抽象，编译器可以让程序员以一种更高层次的语言来表达意图，而不是直接操作底层的字符数据。 总的来说，字符流抽象是编译器设计中的重要概念，它能帮助编译器更好地理解源代码，并有效地生成目标代码。 实现 1// 字符串流 2struct CharStream 3{ 4 CharStream() {} 5 6 // 打开文件 7 bool open(const std::string &amp;amp;path) 8 { 9 return readFile(path, data); 10 } 11 12 // 设置字符串数据 13 inline void setData(const std::string &amp;amp;str) 14 { 15 data = str; 16 index = 0; 17 } 18 inline std::string &amp;amp;getData() { return data; } 19 // 获取字符串中的一段 20 std::string getSbu(uint32_t start, uint32_t end) 21 { 22 assert(start &amp;lt; end); 23 return data.</description>
    </item>
    <item>
      <title>词法分析器</title>
      <link>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/3_lexer/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/3_lexer/index.html</guid>
      <description>词法分析器（也称为扫描器、分词器或词法分析程序）是编译器或解释器的一部分，负责将输入的源代码字符串分解成一系列有意义的最小单元，这些单元被称为标记（Token）。每个标记代表了语言的一个原子单元，如关键字、标识符、常量、运算符和标点符号等。
在编译过程中，词法分析器通常是第一个执行的阶段。它从源代码的开头开始，按顺序读取字符，并根据语言的语法规则生成标记流。这些规则通常由正则表达式或者有限状态自动机来定义，它们描述了如何识别特定类型的标记。
词法分析器的主要任务包括：
分隔：从连续的字符流中分离出独立的标记。 标识化：确定每个标记的类型，并可能附带相关的属性值。 错误处理：检测并报告源代码中的错误，如非法字符、未闭合的字符串或注释等。 例如，在C++编程语言中，以下源代码片段：
1int main() { 2 int x = 10; 3 return 0; 4}词法分析器会将其分解为一系列标记：
标记 类型 值 int 关键字 main 标识符 ( 符号 ) 符号 { 符号 int 关键字 x 标识符 = 符号 10 整数常量 10 ; 符号 } 符号 return 关键字 0 整数常量 0 ; 符号 } 符号 通过这种分割，后续的语法分析器能够更轻松地理解源代码的结构，并进行更复杂的语义检查和代码生成。
作用 词法分析器在编译过程中的主要作用如下：
标记化输入源代码：词法分析器将连续的字符序列分解成离散的标记（Token），这些标记代表了语言的基本元素，如关键字、标识符、常量和运算符等。 提供语法分析所需的输入：词法分析的结果通常是语法分析阶段的主要输入。语法分析器使用这些标记来构建抽象语法树（Abstract Syntax Tree, AST），进而理解程序的结构和语义。 错误检测：词法分析器可以检测源代码中的常见错误，如未闭合的字符串或注释、非法字符以及一些简单的拼写错误等。早期发现并报告错误有助于提高开发效率和程序质量。 简化后续处理：通过将复杂的字符流转换为易于处理的标记流，词法分析器降低了后续编译阶段的复杂性。这使得编译器设计者能够专注于更高层次的语法和语义问题。 增强可读性和可维护性：通过隐藏底层的字符编码细节，词法分析器提高了编译器代码的可读性和可维护性。开发者可以更轻松地理解和修改词法分析器，而不必关心低级别的实现细节。 支持跨平台编译：由于字符流抽象，词法分析器可以在一定程度上独立于具体的字符编码。这种特性使得编译器能够在多种操作系统和硬件平台上运行，而无需针对每个平台进行特定的修改。 总的来说，词法分析器是编译过程中的一个重要组成部分，它负责将复杂的字符数据转换为更容易理解和处理的形式，以便后续阶段对源代码进行深入分析和处理。</description>
    </item>
    <item>
      <title>词元(Token)定义</title>
      <link>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/4_token/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/4_token/index.html</guid>
      <description>词元类别 1// 词元类别 2enum class TkKind : uint16_t 3{ 4 Unknown, // 未知 5 SingleComments, // 单行注释 6 MultipleComments, // 多行注释 7 Annotate, // 注解 8 KeyWord, // 关键字 9 Identifier, // 标志符 10 StringLiteral, // 存在转义的字符串常量 11 StringLiteral2, // 不转义的字符串常量 12 CharLiteral, // 字符常量 13 SIntLiteral, // 有符号整形字符串常量 14 UIntLiteral, // 无符号整形字符串常量 15 Flt32Literal, // 浮点字符串常量 16 Flt64Literal, // 浮点字符串常量 17 Separator, // 分隔符 18 Operator, // 操作符 19 EOS, // 字符流结束 20};分隔符 1// 分隔符 2enum class TkSpEnum : uint16_t 3{ 4 Unknown, // 未知 5 OpenBracket, // [ 左方括号 6 CloseBracket, // ] 右方括号 7 OpenParen, // ( 左括号 8 CloseParen, // ) 右括号 9 OpenBrace, // { 左花括号 10 CloseBrace, // } 右花括号 11 CBSemiColon, // }; 右花括号和分号 12 Colon, // : 冒号 13 SemiColon, // ; 分号 14 Comma, // , 逗号 15 Ellipsis, // .</description>
    </item>
    <item>
      <title>关键字映射表</title>
      <link>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/5_maptable/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/5_maptable/index.html</guid>
      <description>类定义 1struct MapTable 2{ 3 // 初始化信息 4 static void init(); 5 // 查找关键字 6 static TkKeyWord findKeyword(const std::string &amp;amp;szTok) 7 { 8 auto find = mapKey.find(szTok); 9 if (find == mapKey.end()) 10 return TkKeyWord::Unknown; 11 return find-&amp;gt;second; 12 } 13 // 查找标注关键字 14 static TkAnnotate findAnnword(const std::string &amp;amp;szTok) 15 { 16 auto find = mapAnn.find(szTok); 17 if (find == mapAnn.end()) 18 return TkAnnotate::Unknown; 19 return find-&amp;gt;second; 20 } 21 // 查找操作符优先级 22 static int32_t findOpPriority(TkOpEnum op) 23 { 24 auto find = mapOp.</description>
    </item>
    <item>
      <title>词法分析实现</title>
      <link>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/6_scan/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/6_scan/index.html</guid>
      <description>类定义 1struct Lexer 2{ 3 Lexer(CharStream &amp;amp;ics) : pos(0,1), stream(ics) {} 4 5 // 获取词元 6 Token getNext(); 7 // 退回词元 8 void backToken(Token &amp;amp;tok) 9 { 10 stream.back(Char(tok.pos.pos, 0)); 11 pos = tok.pos; 12 } 13 14private: 15 // 跳过空白字符 16 inline void SkipWhiteSpaces() 17 { 18 Char ch = stream.next(); 19 while (ch.isWhiteSpace()) 20 { 21 if (ch.val == &amp;#39;\n&amp;#39;) 22 pos.line++; 23 ch = stream.next(); 24 } 25 stream.</description>
    </item>
    <item>
      <title>案列测试</title>
      <link>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/7_test/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://lang-vm-rt-c.irscript.github.io/2_compiler/1_lexer/7_test/index.html</guid>
      <description>此章节代码对应标记链接：https://github.com/irscript/lang-vm-rt-c/releases/tag/lexer_test
测试文本 1//词法分析测试 2 3/*普通关键字*/ 4package 5require 6using 7void 8bool 9int8 10int16 11int32 12int64 13uint8 14uint16 15uint32 16uint64 17sint 18uint 19pointer 20flt32 21flt64 22string 23cstring 24char 25any 26null 27false 28true 29in 30break 31continue 32goto 33return 34do 35while 36for 37foreach 38if 39elsif 40else 41switch 42case 43default 44private 45protected 46public 47static 48const 49final 50enum 51union 52struct 53entrust 54class 55interface 56this 57super 58friend 59new 60sizeof 61typeof 62instanceof 63cast 64try 65catch 66finally 67throw 68await 69synched 70 71/*注解关键字*/ 72@file 73@func 74@line 75@buildin 76@async 77@volatile 78@inline 79@virtual 80@override 81@operator 82 83/*操作符*/ 84.</description>
    </item>
  </channel>
</rss>